import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Arrays;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;
import java.awt.Color;
import java.util.concurrent.ThreadLocalRandom;

public class SortingVisualization extends JPanel implements ActionListener{
    private JPanel panel;
    //is used for version control of the object, and its value is usually generated by the IDE.
    private static final long serialVersionUID = 1L;
    //WIDTH and HEIGHT represent the width and height of the window in pixels, respectively.
    private static final int WIDTH = 1200;
    private static final int HEIGHT = 1000;
    //BAR_WIDTH is the width of each bar in the visualization, and BAR_GAP is the gap between bars.
    private static final int BAR_WIDTH = 10;
    private static final int BAR_GAP = 5;
    //calculates the number of bars that can be displayed in the window by dividing the window's width by the total width of each bar and gap.
    private static final int NUM_BARS = (WIDTH / (BAR_WIDTH + BAR_GAP)) - 1;
    // the maximum height of a bar in the visualization in pixels
    private static final int MAX_BAR_HEIGHT = HEIGHT - 50;
    private int[] data;
    private JButton bubbleSortButton;
    private JButton selectionSortButton;
    private JButton insertionSortButton;
    private JButton mergeSortButton;
    private JButton quickSortButton;


    public SortingVisualization(){
        data = generateRandomData(NUM_BARS, MAX_BAR_HEIGHT);
        bubbleSortButton = new JButton("Bubble Sort");
        selectionSortButton = new JButton("Selection Sort");
        insertionSortButton = new JButton("Insertion Sort");
        mergeSortButton = new JButton("Merge Sort");
        quickSortButton = new JButton("Quick Sort");
        bubbleSortButton.addActionListener(this);
        selectionSortButton.addActionListener(this);
        insertionSortButton.addActionListener(this);
        mergeSortButton.addActionListener(this);
        quickSortButton.addActionListener(this);
        add(bubbleSortButton);
        add(selectionSortButton);
        add(insertionSortButton);
        add(mergeSortButton);
        add(quickSortButton);
    }

    private int[] generateRandomData(int numBars, int maxBarHeight) {
        //numBars: the number of elements in the array
        //maxBarHeight: the maximum value for each element in the array
        int[] data = new int[numBars];
        for (int i = 0; i < numBars; i++){
            data[i] = (int)(Math.random() * maxBarHeight);
        }
        //an array of random integers with numBars elements and a maximum value of maxBarHeight.
        return data;
    }

    public void paintComponent(Graphics g){
        super.paintComponent(g);
        for (int i = 0; i < NUM_BARS; i++){
            int barHeight = data[i];
            int x = i * (BAR_WIDTH + BAR_GAP) + BAR_GAP;
            int y = HEIGHT - barHeight;
            g.setColor(Color.BLUE);
            g.fillRect(x ,y, BAR_WIDTH, barHeight);
        }
    }

    // Bubble Sort
    public void bubbleSort(){
        for (int i = 0; i < NUM_BARS - 1; i++){
            for (int j = 0; j < NUM_BARS - i - 1; j++){
                if (data[j] > data[j + 1]){
                    int temp = data[j];
                    data[j] = data[j + 1];
                    data[j + 1] = temp;
                    repaint();
                    try{
                        Thread.sleep(50);
                    }catch (InterruptedException e){
                        e.printStackTrace();
                    }
                }
            }
        }
    }
// Selection Sort
    public void selectionSort(){
        for (int i = 0; i < NUM_BARS - 1; i++){
            int minIndex = i;
            for (int j = i + 1; j < NUM_BARS; j++){
                if (data[j] < data[minIndex]){
                    minIndex = j;
                }
            }
            int temp = data[i];
            data[i] = data[minIndex];
            data[minIndex] = temp;
            repaint();
            try{
                Thread.sleep(50);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
    // Insertion Sort
    public void insertionSort(){
        for (int i = 0; i < NUM_BARS; i++){
            int key = data[i];
            int j = i - 1;
            while (j >= 0 && data[j] > key){
                data[j + 1] = data[j];
                j = j - 1;
                repaint();
                try{
                    Thread.sleep(50);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
            data[j + 1] = key;
        }
    }
    // Merge Sort
    public void mergeSort(){
        data = mergeSort(data);
    }
    private int[] mergeSort(int[] arr){
        if (arr.length <= 1){
            return arr;
        }
        int mid = arr.length / 2;
        int[] left = Arrays.copyOfRange(arr, 0 ,mid);
        int[] right = Arrays.copyOfRange(arr, mid, arr.length);
        left = mergeSort(left);
        right = mergeSort(right);
        return merge(left, right);
    }
    private int[] merge(int[] left, int[] right){
        int[] result = new int[left.length + right.length];
        int i = 0, j = 0, k = 0;
        while (i < left.length && j < right.length){
            if (left[i] < right[j]){
                result[k++] = left[i++];
            }else {
                result[k++] = right[j++];
            }
            repaint();
            try {
                Thread.sleep(50);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        while (i < left.length){
            result[k++] = left[i++];
            repaint();
            try {
                Thread.sleep(50);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        while ((j < right.length)){
            result[k++] = right[j++];
            repaint();
            try {
                Thread.sleep(50);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
        data = result;
        return result;
    }
    // Quick Sort
    public void quickSort(int low, int high){
        if (low < high){
            int pivotIndex = partition(low, high);
            quickSort(low, pivotIndex - 1);
            quickSort(pivotIndex + 1, high);
        }
    }
    private int partition(int low, int high){
        int pivot = data[high];
        int i = low - 1;
        for (int j = low; j <= high; j++){
            if (data[j] < pivot){
                i++;
                int temp = data[i];
                data[i] = data[j];
                data[j] = temp;
                repaint();
                try{
                    Thread.sleep(50);
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
        }
        int temp = data[i + 1];
        data[i + 1] = data[high];
        data[high] = temp;
        repaint();
        try{
            Thread.sleep(50);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
        return i + 1;
    }
    // handle button clicks
    public void actionPerformed(ActionEvent e){
        if (e.getSource() == bubbleSortButton){
            Thread thread = new Thread(){
                public void run(){
                    bubbleSort();
                }
            };
            thread.start();
        } else if (e.getSource() == selectionSortButton) {
            Thread thread = new Thread(){
                public void run(){
                    selectionSort();
                }
            };
            thread.start();
        } else if (e.getSource() == insertionSortButton) {
            Thread thread = new Thread(){
                public void run(){
                    insertionSort();
                }
            };
            thread.start();
        }else if (e.getSource() == mergeSortButton){
            Thread thread = new Thread(){
                public void run(){
                    mergeSort();
                }
            };
            thread.start();
        } else if (e.getSource() == quickSortButton) {
            Thread thread = new Thread(){
                public void run(){
                    quickSort(0, NUM_BARS - 1);
                }
            };
            thread.start();
        }
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Soring Visualization");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        SortingVisualization panel = new SortingVisualization();
        panel.setPreferredSize(new Dimension(WIDTH,HEIGHT));
        frame.getContentPane().add(panel);
        frame.pack();
        SortingVisualization visualization = new SortingVisualization();
        frame.add(visualization);
        frame.setVisible(true);
    }
}